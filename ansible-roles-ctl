#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import yaml
import os.path
import re
import shutil
import ansible.constants as C
from ansible.galaxy import Galaxy
from ansible.playbook.role.requirement import RoleRequirement
from ansible.galaxy.role import GalaxyRole
from git import Repo,Commit


class AnsibleRolesCtlException(Exception):
    """AnsibleRolesCtl exceptions"""

class InvalidAnsibleRole(AnsibleRolesCtlException):
    """Ansible role is in an unusable state"""

class NonExistingAnsibleRoleTarget(AnsibleRolesCtlException):
    """Ansible role is setup to target a non-existing tag or branch"""

# reusing default options from the CLI.
# there is no way to get them properly because it is merged with the
# CLI parser.
class GalaxyDefaultOptions:
    def __init__(self):
        self.ignore_certs = C.GALAXY_IGNORE_CERTS
        self.roles_path = C.DEFAULT_ROLES_PATH

# reusing GalaxyRole initialization to obtain name and path properly
class AnsibleRole(GalaxyRole):

    tag_version_regex = "^v(?P<version>\d+\.\d+\.(\d+)?)$"

    def __init__(self, **role):
        galaxy = Galaxy(GalaxyDefaultOptions())
        super(AnsibleRole, self).__init__(galaxy, **role)

        self.repo = None
        if self.isInstalled():
            try:
                self.repo = Repo(self.path)
            except Exception as e:
                pass

        # if no version specified, then master is considered default
        if not self.version:
            self.version = 'master'

    def isInstalled(self):
        return os.path.exists(self.path)

    def localBranch(self):
        if self.repo.head.is_detached:
            return None

        return self.repo.head.reference

    def remoteBranch(self):
        if self.repo.head.is_detached:
            return None

        # used configured tracking branch if exist
        branch = self.localBranch().tracking_branch()
        if branch:
            return branch

        # or try a matching branch name in 'origin' remote
        if self.localBranch().name in self.repo.remotes.origin.refs:
            ref = self.repo.remotes.origin.refs[self.localBranch().name]
            self.localBranch().set_tracking_branch(ref)
            print("role '{}' lacked tracking branch configuration, fixed".format(self.name))
            return ref

        return None

    def isTargetingTag(self):
        if re.match(self.tag_version_regex, self.version):
            return True
        else:
            return False

    def testValid(self):
        if self.scm and self.scm != 'git':
            raise InvalidAnsibleRole("using an unsupported SCM")
        if not re.search("https?://", self.src):
            raise InvalidAnsibleRole("from Ansible Galaxy")

        # if role is not installed yet, then skip following tests
        if not self.isInstalled():
            return

        if not self.repo:
            raise InvalidAnsibleRole("not a valid SCM directory")
        if self.repo.bare:
            raise InvalidAnsibleRole("bare repository")
        if self.localBranch() is not None and self.remoteBranch() is None:
            raise InvalidAnsibleRole("on a local branch '{}' (no corresponding remote branch)".format(self.localBranch().name))

        self.version_commit = None
        if self.isTargetingTag():
            try:
                self.version_commit = self.repo.tags[self.version].commit
            except ValueError as e:
                raise InvalidAnsibleRole("targeting an unexisting version ({})".format(self.version))
        elif self.localBranch() is None:
            raise InvalidAnsibleRole("on a detached commit which does not match a version tag")

        elif self.localBranch().name != self.version:
            raise InvalidAnsibleRole("following branch '{}' but not the requirements ({})".format(self.localBranch().name, self.version))

        return

    def fetchUpdates(self):
        self.repo.remotes.origin.fetch()

    def commitsAhead(self):
        if self.repo.head.is_detached:
            return []

        return Commit.iter_items(self.repo, "{}..HEAD".format(self.remoteBranch()))

    def commitsBehind(self):
        if self.repo.head.is_detached:
            return []

        return Commit.iter_items(self.repo, "HEAD..{}".format(self.remoteBranch()))

    def versionTags(self):
        list = {}
        for t in self.repo.tags:
            m = re.match(self.tag_version_regex, t.name)
            if m:
                #list[t.commit.hexsha] = m.group('version')
                list[t.commit] = m.group('version')
        return list

    def uninstall(self):
        if not self.isInstalled():
            return

        shutil.rmtree(self.path)

    def install(self):
        if self.repo:
            return False

        self.repo = Repo.clone_from(self.src, self.path)

        if self.isTargetingTag():
            if self.version in self.repo.tags:
                self.repo.tags[self.version].checkout
            else:
                self.uninstall()
                raise NonExistingAnsibleRoleTarget("setup to target version '{}', but it does not exist".format(self.version))

        else:
            if self.version in self.repo.heads:
                self.repo.heads[self.version].checkout
            else:
                self.uninstall()
                raise NonExistingAnsibleRoleTarget("setup to follow branch '{}', but it does not exist".format(self.version))

        return True

    def update(self, new_target_version=None):
        if not self.repo:
            print("role '{}' is not yet installed".format(self.name))
            return False

        if self.repo.is_dirty():
            print("role '{}' has local changes (please commit or cleanup)".format(role.name))
            return False

        self.fetchUpdates()

        if new_target_version:
            new_target_tag = "v{}".format(new_target_version)
            if new_target_tag not in self.repo.tags:
                print("role '{}' cannot be upgraded to nonexisting version '{}'".format(self.name, new_target_version))
                return False

        else:
            all_tags = self.versionTags()
            for commit in self.commitsBehind():
                if commit in all_tags:
                    new_target_version = all_tags[commit]

            if not new_target_version:
                print("role '{}' is already at the latest version".format(self.name))
                return False

            new_target_tag = "v{}".format(new_target_version)

        self.repo.head.reference = new_target_tag
        self.repo.head.reset(index=True, working_tree=True)
        self.version = new_target_tag

        return True

def load_deps(selected_roles, args):
    try:
        stream = open("requirements.yml", "r")
    except Exception as e:
        print("Unable to open requirements file")
        exit(-1)

    try:
        required_roles = yaml.safe_load(stream)
    except Exception as e:
        print("Unable to load data from the requirements file")
        exit(-1)

    if required_roles is None:
        print("No roles found in requirements file")
        exit(0)

    role_list = dict()
    for dep in required_roles:
        role_info = RoleRequirement.role_yaml_parse(dep)
        role = AnsibleRole(**role_info)

        if selected_roles and role.name not in selected_roles:
            continue

        try:
            role.testValid()
        except InvalidAnsibleRole, e:
            if not args.quiet:
                print("role '{}' is invalid: {}".format(role.name, e.message))
            continue

        role_list[role.name] = role

    return role_list

def display_changelog(commit, new_versions):
    try:
        changelog = commit.tree['CHANGELOG.yml']
    except Exception as e:
        print("  no changelog file ('CHANGELOG.yml') could be found")
        return

    try:
        changelog_entries = yaml.safe_load(changelog.data_stream)
    except Exception as e:
        print("  changelog file ('CHANGELOG.yml') could not be parsed")
        return

    print("  changelog:")
    for version in sorted(new_versions):
        if version in changelog_entries:
            print("    {}:".format(version))
            for entry in changelog_entries[version]:
                print("      - {}".format(entry))
        else:
            print("    {}: changelog entry is missing for this version".format(v))

def action_status(dep_list, selected_roles, args):
    for role_name in sorted(dep_list.keys()):
        if selected_roles and role_name not in selected_roles:
            continue

        role = dep_list[role_name]

        if role.isInstalled():
            print("role '{}' is properly installed".format(role.name)),

            role.fetchUpdates()

            if role.version_commit or role.localBranch() is None:
                all_tags = role.versionTags()

                if role.version_commit:
                    print("at version '{}'".format(role.version))
                else:
                    print
                    if self.head.commit in all_tags:
                        print("  is targeting version '{}' but repository is at version '{}'".format(role.version, all_tags[self.head.commit]))
                    else:
                        print("  is at a commit which corresponds to no known version")

                if role.localBranch() is None:
                    print("  is detached from a branch, cannot check for new versions")

                else:
                    new_versions = []
                    for commit in role.commitsBehind():
                        if commit in all_tags:
                            new_versions.append(all_tags[commit])

                    if new_versions:
                        print("  has new version(s) available: {}".format(", ".join(new_versions)))
                        if args.changelog:
                            display_changelog(commit, new_versions)

                if role.repo.is_dirty():
                    print("  has local changes (please commit or cleanup)".format(role.name))

            else:
                print("using branch '{}'".format(role.localBranch().name))

                if role.localBranch().commit == role.remoteBranch().commit:
                    print("  is up-to-date with origin")

                else:
                    la = list(role.commitsAhead())
                    lb = list(role.commitsBehind())
                    if la and lb:
                        print("  has diverged from origin")
                    if la:
                        print("  is {} commits ahead".format(len(la)))
                        # TODO: display CHANGELOG diff
                    if lb:
                        print("  is {} commits behind".format(len(lb)))
                        # TODO: display CHANGELOG diff

        else:
            print("role '{}' is missing".format(role.name))

def action_install(dep_list, selected_roles, args):
    for role_name in sorted(dep_list.keys()):
        if selected_roles and role_name not in selected_roles:
            continue

        role = dep_list[role_name]

        if role.isInstalled():
            if not args.quiet:
                print("role '{}' is already installed".format(role.name))

        else:
            try:
                role.install()
                if not args.quiet:
                  print("role '{}' has been installed".format(role.name))
            except Exception as e:
                print("role '{}' installation failed: {}".format(role.name, e))

def action_update(dep_list, selected_roles, args):
    selected_versions = {}
    for role_name in args.roles:
        l = role_name.split("=")
        if len(l) > 1:
            selected_versions[l[0]] = l[1]

    for role_name in sorted(dep_list.keys()):
        if selected_roles and role_name not in selected_roles:
            continue

        role = dep_list[role_name]

        if role.isInstalled():
            new_target_version = None
            if role.name in selected_versions:
                new_target_version = selected_versions[role.name]

            if role.update(new_target_version):
                pass
                # TODO: update requirements.yml

        else:
            print("role '{}' is not yet installed".format(role.name))


# declare available subcommands and options
parser = argparse.ArgumentParser(description='Manage roles installation')
parser.add_argument('--version', action='version', version='%(prog)s 0.0.1')
parser.add_argument('--quiet', '-q', action='store_true', help='less verbose display')
subparsers = parser.add_subparsers(help='sub-command help')
parser_status = subparsers.add_parser('status', help='inform about roles installation status')
parser_status.set_defaults(func=action_status)
parser_status.add_argument('--changelog', '-c', action='store_true', help='display changelog entries for new versions')
parser_status.add_argument('roles', nargs='*', help='limit command to this list of roles')
parser_install = subparsers.add_parser('install', help='install roles')
parser_install.set_defaults(func=action_install)
parser_install.add_argument('roles', nargs='*', help='limit command to this list of roles')
parser_update = subparsers.add_parser('update', help='update roles')
parser_update.set_defaults(func=action_update)
parser_update.add_argument('roles', nargs='*', help='limit command to this list of roles; "role=<version>" syntax is possible to enforce a specific version')

# let's parse
args = parser.parse_args()

# load user config
selected_roles = []
if hasattr(args, 'roles'):
    selected_roles = map(lambda i: i.split("=")[0], args.roles)
dep_list = load_deps(selected_roles, args)

# action!
if hasattr(args, 'func'):
    args.func(dep_list, selected_roles, args)
else:
    parser.print_help()

