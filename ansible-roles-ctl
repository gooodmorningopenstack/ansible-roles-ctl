#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import yaml
import os.path
import re
import shutil
import ansible.constants as C
from ansible.galaxy import Galaxy
from ansible.playbook.role.requirement import RoleRequirement
from ansible.galaxy.role import GalaxyRole
from git import Repo,Commit


# reusing default options from the CLI.
# there is no way to get them properly because it is merged with the
# CLI parser.
class GalaxyDefaultOptions:
    def __init__(self):
        self.ignore_certs = C.GALAXY_IGNORE_CERTS
        self.roles_path = C.DEFAULT_ROLES_PATH

# reusing GalaxyRole initialization to obtain name and path properly
class AnsibleRole(GalaxyRole):

    tag_version_regex = "^v(?P<version>\d+\.\d+\.(\d+)?)$"

    def __init__(self, **role):
        galaxy = Galaxy(GalaxyDefaultOptions())
        super(AnsibleRole, self).__init__(galaxy, **role)

        self.repo = None
        if self.isInstalled():
            try:
                self.repo = Repo(self.path)
            except Exception as e:
                pass

        # if no version specified, then master is considered default
        if not self.version:
            self.version = 'master'

    def isInstalled(self):
        return os.path.exists(self.path)

    def localBranch(self):
        return self.repo.head.reference

    def remoteBranch(self):
        # used configured tracking branch if exist
        branch = self.localBranch().tracking_branch()
        if branch:
            return branch

        # or try a matching branch name in 'origin' remote
        if self.localBranch().name in self.repo.remotes.origin.refs:
            ref = self.repo.remotes.origin.refs[self.localBranch().name]
            self.localBranch().set_tracking_branch(ref)
            print("role '{}' lacked tracking branch configuration, fixed".format(self.name))
            return ref

        return None

    def isTargetingTag(self):
        if re.match(self.tag_version_regex, self.version):
            return True
        else:
            return False

    def isValid(self):
        if self.scm and self.scm != 'git':
            print("role '{}' is using an unsupported SCM, skipping".format(self.name))
            return False
        if not re.search("https?://", self.src):
            print("role '{}' is from Ansible Galaxy, skipping".format(self.name))
            return False

        # if role is not installed yet, then skip following tests
        if not self.isInstalled():
            return True

        if not self.repo:
            print("role '{}' is not a valid SCM directory, skipping".format(self.name))
            return False
        if self.repo.bare:
            print("role '{}' is a bare repository, skipping".format(self.name))
            return False
        if self.remoteBranch() is None:
            print("role '{}' is on a local branch (no corresponding remote branch), skipping".format(self.name))
            return False

        # TODO: check if the local version match the configured one
        self.version_commit = None
        if self.isTargetingTag():
            try:
                self.version_commit = self.repo.tags[self.version].commit
            except ValueError as e:
                print("role '{}' is targeting an unexisting version ({}), skipping".format(self.name, self.version))
                return False
        elif self.localBranch().name != self.version:
            print("role '{}' is not following the branch defined in requirements, skipping".format(self.name))
            return False

        return True

    def fetchUpdates(self):
        self.repo.remotes.origin.fetch()

    def commitsAhead(self):
        return Commit.iter_items(self.repo, "{}..HEAD".format(self.remoteBranch()))

    def commitsBehind(self):
        return Commit.iter_items(self.repo, "HEAD..{}".format(self.remoteBranch()))

    def versionTags(self):
        list = {}
        for t in self.repo.tags:
            m = re.match(self.tag_version_regex, t.name)
            if m:
                #list[t.commit.hexsha] = m.group('version')
                list[t.commit] = m.group('version')
        return list

    def uninstall(self):
        if not self.isInstalled():
            return

        shutil.rmtree(self.path)

    def install(self):
        if self.repo:
            print("role '{}' is already installed".format(self.name))
            return

        self.repo = Repo.clone_from(self.src, self.path)

        if self.isTargetingTag():
            if self.version in self.repo.tags:
                self.repo.tags[self.version].checkout
            else:
                self.uninstall()
                raise ValueError("role '{}' is setup to target version '{}', but it does not exist".format(self.name, self.version))

        else:
            if self.version in self.repo.heads:
                self.repo.heads[self.version].checkout
            else:
                self.uninstall()
                raise ValueError("role '{}' is setup to follow branch '{}', but it does not exist".format(self.name, self.version))

def load_deps(args):
    try:
        stream = open("requirements.yml", "r")
    except Exception as e:
        print("Unable to open requirements file")
        exit(-1)

    try:
        required_roles = yaml.safe_load(stream)
    except Exception as e:
        print("Unable to load data from the requirements file")
        exit(-1)

    if required_roles is None:
        print("No roles found in requirements file")
        exit(0)

    role_list = dict()
    for dep in required_roles:
        role_info = RoleRequirement.role_yaml_parse(dep)
        role = AnsibleRole(**role_info)

        if hasattr(args, 'roles') and args.roles and role.name not in args.roles:
            continue

        if not role.isValid():
            continue

        role_list[role.name] = role

    return role_list

def display_changelog(commit, new_versions):
    try:
        changelog = commit.tree['CHANGELOG.yml']
    except Exception as e:
        print("  no changelog file ('CHANGELOG.yml') could be found")
        return

    try:
        changelog_entries = yaml.safe_load(changelog.data_stream)
    except Exception as e:
        print("  changelog file ('CHANGELOG.yml') could not be parsed")
        return

    print("  changelog:")
    for version in sorted(new_versions):
        if version in changelog_entries:
            print("    {}:".format(version))
            for entry in changelog_entries[version]:
                print("      - {}".format(entry))
        else:
            print("    {}: changelog entry is missing for this version".format(v))

def action_status(dep_list, args):
    for role_name in sorted(dep_list.keys()):
        if args.roles and role_name not in args.roles:
            continue

        role = dep_list[role_name]

        if role.isInstalled():
            print("role '{}' is properly installed".format(role.name))

            if role.repo.is_dirty():
                print("  has local changes (please commit or cleanup)".format(role.name))

            role.fetchUpdates()

            local_commit = role.localBranch().commit
            remote_commit = role.remoteBranch().commit

            if role.version_commit:
                if role.localBranch().commit == role.version_commit:
                    print("  is at version '{}'".format(role.version))
                else:
                    print("  is targeting version '{}' but repository do not match".format(role.version))

                all_tags = role.versionTags()
                new_versions = []
                for commit in role.commitsBehind():
                    if commit in all_tags:
                        new_versions.append(all_tags[commit])

                if new_versions:
                    print("  has new version(s) available: {}".format(", ".join(new_versions)))
                    if args.changelog:
                        display_changelog(commit, new_versions)

            else:
                print("  using branch '{}'".format(role.localBranch().name))

                if local_commit == remote_commit:
                    print("  is up-to-date with origin")

                else:
                    la = list(role.commitsAhead())
                    lb = list(role.commitsBehind())
                    if la and lb:
                        print("  has diverged from origin")
                    if la:
                        print("  has {} commits ahead".format(len(la)))
                        # TODO: display CHANGELOG diff
                    if lb:
                        print("  has {} commits behind".format(len(lb)))
                        # TODO: display CHANGELOG diff

        else:
            print("role '{}' is missing".format(role.name))

def action_install(dep_list, args):
    for role_name in sorted(dep_list.keys()):
        if args.roles and role_name not in args.roles:
            continue

        role = dep_list[role_name]

        if role.isInstalled():
            print("role '{}' is already installed".format(role.name))

        else:
            print("role '{}' is being installedâ€¦".format(role.name))
            try:
                role.install()
                print("  done")
            except Exception as e:
                print("  failed: {}".format(e))


# declare available subcommands and options
parser = argparse.ArgumentParser(description='Manage roles installation')
parser.add_argument('--version', action='version', version='%(prog)s 0.0.1')
subparsers = parser.add_subparsers(help='sub-command help')
parser_status = subparsers.add_parser('status', help='inform about roles installation status')
parser_status.set_defaults(func=action_status)
parser_status.add_argument('--changelog', '-c', action='store_true', help='display changelog entries for new versions')
parser_status.add_argument('roles', nargs='*', help='limit command to this list of roles')
parser_install = subparsers.add_parser('install', help='install roles')
parser_install.set_defaults(func=action_install)
parser_install.add_argument('roles', nargs='*', help='limit command to this list of roles')

# let's parse
args = parser.parse_args()
# load user config
dep_list = load_deps(args)

# action!
if hasattr(args, 'func'):
    args.func(dep_list, args)
else:
    parser.print_help()

